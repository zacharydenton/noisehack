<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Noisehack</title>
    <link href="http://noisehack.com/rss.xml" rel="self" />
    <link href="http://noisehack.com" />
    <id>http://noisehack.com/rss.xml</id>
    <author>
        <name>Zach Denton</name>
        <email>z@chdenton.com</email>
    </author>
    <updated>2013-08-01T00:00:00Z</updated>
    <entry>
    <title>How to Generate Noise with the Web&nbsp;Audio&nbsp;API</title>
    <link href="http://noisehack.com/how-to-generate-noise-with-web-audio-api/" />
    <id>http://noisehack.com/how-to-generate-noise-with-web-audio-api/</id>
    <published>2013-08-01T00:00:00Z</published>
    <updated>2013-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>One of the main shortcomings of the <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html">Web Audio API</a> is that there’s no native support for generating noise. This post will teach you how to overcome that limitation.</p>
<!--more-->

<h2 id="white-noise">White Noise</h2>
<p>The most common type of noise is <em>white noise</em>. White noise is perfectly random audio data with a flat frequency spectrum.</p>
<p>To produce white noise, we simply compute a series of random samples<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. One way to do this with the Web Audio API is to use a <code>ScriptProcessorNode</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> bufferSize = <span class="dv">4096</span>;
<span class="kw">var</span> whiteNoise = <span class="ot">audioContext</span>.<span class="fu">createJavaScriptNode</span>(bufferSize, <span class="dv">1</span>, <span class="dv">1</span>);
<span class="ot">whiteNoise</span>.<span class="fu">onaudioprocess</span> = <span class="kw">function</span>(e) {
    <span class="kw">var</span> output = <span class="ot">e</span>.<span class="ot">outputBuffer</span>.<span class="fu">getChannelData</span>(<span class="dv">0</span>);
    <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; bufferSize; i++) {
        output[i] = <span class="ot">Math</span>.<span class="fu">random</span>() * <span class="dv">2</span> - <span class="dv">1</span>;
    }
}

<span class="ot">whiteNoise</span>.<span class="fu">connect</span>(<span class="ot">audioContext</span>.<span class="fu">destination</span>);</code></pre>
<p>This works, but depending on the application, <a href="https://medium.com/web-audio/61a836e28b42">it might be inefficient</a>. With a buffer size of 4096, the <code>onaudioprocess</code> callback is being executed around 10 times per second. Not a problem if you’re building an ambient sound generator that only uses a single instance of white noise, but if you’re building, say, a polyphonic synthesizer with noise-modulated filters, this computational overhead will introduce latency.</p>
<p>A more efficient approach is to generate a buffer of white noise and then loop through it:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> bufferSize = <span class="dv">2</span> * <span class="ot">audioContext</span>.<span class="fu">sampleRate</span>,
    noiseBuffer = <span class="ot">audioContext</span>.<span class="fu">createBuffer</span>(<span class="dv">1</span>, bufferSize, <span class="ot">audioContext</span>.<span class="fu">sampleRate</span>),
    output = <span class="ot">noiseBuffer</span>.<span class="fu">getChannelData</span>(<span class="dv">0</span>);
<span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; bufferSize; i++) {
    output[i] = <span class="ot">Math</span>.<span class="fu">random</span>() * <span class="dv">2</span> - <span class="dv">1</span>;
}

<span class="kw">var</span> whiteNoise = <span class="ot">audioContext</span>.<span class="fu">createBufferSource</span>();
<span class="ot">whiteNoise</span>.<span class="fu">buffer</span> = noiseBuffer;
<span class="ot">whiteNoise</span>.<span class="fu">loop</span> = <span class="kw">true</span>;
<span class="ot">whiteNoise</span>.<span class="fu">start</span>(<span class="dv">0</span>);

<span class="ot">whiteNoise</span>.<span class="fu">connect</span>(<span class="ot">audioContext</span>.<span class="fu">destination</span>);</code></pre>
<p>This code generates two seconds of white noise and then loops through it continuously. The primary disadvantage of this approach is that the same chunk of noise is being reused, over and over. Depending on how large the noise buffer is, this means you might be able to hear the noise repeating. In practice, I’ve found that this is only noticeable when the noise buffer is less than two seconds long.</p>
<h2 id="pink-noise">Pink Noise</h2>
<p>The next type of noise we’ll be generating is <em>pink noise</em>. Whereas white noise has equal power across the frequency spectrum, pink noise <em>sounds</em> like it has equal power across the frequency spectrum. Our ears process frequencies logarithmically, and pink noise takes this into account. In terms of ambient noise, I find that pink noise sounds <em>much</em> nicer than white noise, which is too harsh in the upper frequencies.</p>
<p>To generate pink noise, we’ll approximate the effects of a -3dB/octave filter using <a href="http://www.musicdsp.org/files/pink.txt">Paul Kellet’s refined method</a>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> bufferSize = <span class="dv">4096</span>;
<span class="kw">var</span> pinkNoise = (<span class="kw">function</span>() {
    <span class="kw">var</span> b0, b1, b2, b3, b4, b5, b6;
    b0 = b1 = b2 = b3 = b4 = b5 = b6 = <span class="fl">0.0</span>;
    node = <span class="ot">audioContext</span>.<span class="fu">createJavaScriptNode</span>(bufferSize, <span class="dv">1</span>, <span class="dv">1</span>);
    <span class="ot">node</span>.<span class="fu">onaudioprocess</span> = <span class="kw">function</span>(e) {
        <span class="kw">var</span> output = <span class="ot">e</span>.<span class="ot">outputBuffer</span>.<span class="fu">getChannelData</span>(<span class="dv">0</span>);
        <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; bufferSize; i++) {
            <span class="kw">var</span> white = <span class="ot">Math</span>.<span class="fu">random</span>() * <span class="dv">2</span> - <span class="dv">1</span>;
            b0 = <span class="fl">0.99886</span> * b0 + white * <span class="fl">0.0555179</span>;
            b1 = <span class="fl">0.99332</span> * b1 + white * <span class="fl">0.0750759</span>;
            b2 = <span class="fl">0.96900</span> * b2 + white * <span class="fl">0.1538520</span>;
            b3 = <span class="fl">0.86650</span> * b3 + white * <span class="fl">0.3104856</span>;
            b4 = <span class="fl">0.55000</span> * b4 + white * <span class="fl">0.5329522</span>;
            b5 = -<span class="fl">0.7616</span> * b5 - white * <span class="fl">0.0168980</span>;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * <span class="fl">0.5362</span>;
            output[i] *= <span class="fl">0.11</span>; <span class="co">// (roughly) compensate for gain</span>
            b6 = white * <span class="fl">0.115926</span>;
        }
    }
    <span class="kw">return</span> node;
})();

<span class="ot">pinkNoise</span>.<span class="fu">connect</span>(<span class="ot">audioContext</span>.<span class="fu">destination</span>);</code></pre>
<p>So the code to generate pink noise is quite a bit more complex than the code to generate white noise. The <code>pinkNoise</code> node is wrapped within a closure because we want the values of <code>b0</code> through <code>b6</code> (the filter state) to persist between calls to <code>onaudioprocess</code>. The 0.11 scaling factor is taken from the <a href="http://sourceforge.net/p/csound/csound6-git/ci/master/tree/Opcodes/pitch.c#l1336">Csound source code</a>.</p>
<h2 id="brownian-noise">Brownian Noise</h2>
<p>Let’s move on to <em>Brownian noise</em> (also known as brown noise or red noise). Brownian noise decreases in power by 12dB/octave, and sounds like a waterfall. Here’s how to generate Brownian noise with the Web Audio API:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> bufferSize = <span class="dv">4096</span>;
<span class="kw">var</span> brownNoise = (<span class="kw">function</span>() {
    <span class="kw">var</span> lastOut = <span class="fl">0.0</span>;
    node = <span class="ot">audioContext</span>.<span class="fu">createJavaScriptNode</span>(bufferSize, <span class="dv">1</span>, <span class="dv">1</span>);
    <span class="ot">node</span>.<span class="fu">onaudioprocess</span> = <span class="kw">function</span>(e) {
        <span class="kw">var</span> output = <span class="ot">e</span>.<span class="ot">outputBuffer</span>.<span class="fu">getChannelData</span>(<span class="dv">0</span>);
        <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; bufferSize; i++) {
            <span class="kw">var</span> white = <span class="ot">Math</span>.<span class="fu">random</span>() * <span class="dv">2</span> - <span class="dv">1</span>;
            output[i] = (lastOut + (<span class="fl">0.02</span> * white)) / <span class="fl">1.02</span>;
            lastOut = output[i];
            output[i] *= <span class="fl">3.5</span>; <span class="co">// (roughly) compensate for gain</span>
        }
    }
    <span class="kw">return</span> node;
})();

<span class="ot">brownNoise</span>.<span class="fu">connect</span>(<span class="ot">audioContext</span>.<span class="fu">destination</span>);</code></pre>
<p>Again, a closure is used to keep track of variables that need to persist between calls to <code>onaudioprocess</code>.</p>
<h2 id="demo">Demo</h2>
<p>Here are the three different kinds of noise in action:</p>
<p>
<button id="white-demo">
White Noise
</button>
<button id="pink-demo">
Pink Noise
</button>
<button id="brown-demo">
Brown Noise
</button>
<script type="text/javascript">
var audioContext = new webkitAudioContext();

var bufferSize = 4096;

var whiteNoise = audioContext.createJavaScriptNode(bufferSize, 1, 1);
whiteNoise.onaudioprocess = function(e) {
    var output = e.outputBuffer.getChannelData(0);
    for (var i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
    }
}
var whiteGain = audioContext.createGainNode();
whiteGain.gain.value = 0;
whiteNoise.connect(whiteGain);
whiteGain.connect(audioContext.destination);

var pinkNoise = (function() {
    var b0, b1, b2, b3, b4, b5, b6;
    b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
    node = audioContext.createJavaScriptNode(bufferSize, 1, 1);
    node.onaudioprocess = function(e) {
        var output = e.outputBuffer.getChannelData(0);
        for (var i = 0; i < bufferSize; i++) {
            var white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            output[i] *= 0.11; // (roughly) compensate for gain
            b6 = white * 0.115926;
        }
    }
    return node;
})();
var pinkGain = audioContext.createGainNode();
pinkGain.gain.value = 0;
pinkNoise.connect(pinkGain);
pinkGain.connect(audioContext.destination);

var brownNoise = (function() {
    var lastOut = 0.0;
    node = audioContext.createJavaScriptNode(bufferSize, 1, 1);
    node.onaudioprocess = function(e) {
        var output = e.outputBuffer.getChannelData(0);
        for (var i = 0; i < bufferSize; i++) {
            var white = Math.random() * 2 - 1;
            output[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = output[i];
            output[i] *= 3.5; // (roughly) compensate for gain
        }
    }
    return node;
})();
var brownGain = audioContext.createGainNode();
brownGain.gain.value = 0;
brownNoise.connect(brownGain);
brownGain.connect(audioContext.destination);

var toggleDemo = function(text, gain) {
    var handler = function(e) {
        if (gain.gain.value == 0.0) {
            $(e.target).text("Stop");
            gain.gain.value = 0.3;
        } else {
            $(e.target).text(text);
            gain.gain.value = 0.0;
        }
    };
    return handler;
};

$("#white-demo").click(toggleDemo("White Noise", whiteGain));
$("#pink-demo").click(toggleDemo("Pink Noise", pinkGain));
$("#brown-demo").click(toggleDemo("Brown Noise", brownGain));
</script>
</p>

<p>Just click on the buttons to turn the noise on and off.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In the Web Audio API, samples are floating-point numbers in the range [-1.0, 1.0].<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
