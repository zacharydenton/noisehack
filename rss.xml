<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Noisehack</title>
    <link href="http://noisehack.com/rss.xml" rel="self" />
    <link href="http://noisehack.com" />
    <id>http://noisehack.com/rss.xml</id>
    <author>
        <name>Zach Denton</name>
        <email>z@chdenton.com</email>
    </author>
    <updated>2011-12-29T00:00:00Z</updated>
    <entry>
    <title>Music Server Revisited: Streaming with sshfs and mp3fs</title>
    <link href="http://noisehack.com/music-server-revisited-streaming-with-sshfs-and-mp3fs/" />
    <id>http://noisehack.com/music-server-revisited-streaming-with-sshfs-and-mp3fs/</id>
    <published>2011-12-29T00:00:00Z</published>
    <updated>2011-12-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A while back, I wrote about <a href="/build-a-media-server-with-ampache-and-transmission/">streaming music with Ampache</a>. Ampache is a nice piece of software, with some unique advantages (like Android support). However, there are simpler ways to stream music. I’m going to show you how to stream music using sshfs and (optionally) mp3fs. One of the best things about this approach is that it allows you to access your collection with the media player of your choice.</p>
<!--more-->

<p>Before you start, you’re going to need a Linux machine with your music collection on it (the server). You will also need another Linux machine to act as the client (e.g. a laptop with a small hard drive).</p>
<h2 id="configuring-the-server">Configuring the server</h2>
<h3 id="install-the-ssh-server">Install the ssh server</h3>
<p>The first thing you’re going to want to do is install an ssh server, if it’s not already installed.</p>
<pre><code>$ sudo aptitude install openssh-server</code></pre>
<p>If your music is already compressed, or if you just have a very fast internet connection, you’re done configuring the server. Otherwise, read on to learn how to transcode your music on-the-fly with mp3fs.</p>
<h3 id="set-up-mp3fs">Set up mp3fs</h3>
<blockquote>
<p>MP3FS is a read-only FUSE filesystem which transcodes audio formats (currently FLAC) to MP3 on the fly when opened and read. This was written to enable me to use my FLAC collection with software and/or hardware which only understands the MP3 format e.g. gmediaserver to a Netgear MP101 MP3 player. — <a href="http://khenriks.github.com/mp3fs/">Kristofer Henriksson</a></p>
</blockquote>
<p>If you have any music in FLAC format, you’re probably not going to be able to stream it without first transcoding to MP3. mp3fs solves this problem. First, install it.</p>
<pre><code>$ sudo aptitude install mp3fs</code></pre>
<p>NOTE: Depending on your distro, the repositories might have an outdated version of mp3fs. If the following commands don’t work, try installing a newer version of mp3fs (either by compiling it yourself or finding a newer package).</p>
<p>Now that it’s installed, we’ll set it up. Create a folder for the mp3fs:</p>
<pre><code>$ mkdir ~/MP3</code></pre>
<p>Next, add an entry to <code>/etc/fstab</code> to automatically mount the mp3fs:</p>
<pre><code># cat &gt;&gt; /etc/fstab &lt;&lt; EOF
mp3fs#/home/USER/Music /home/USER/MP3 fuse allow_other,ro,bitrate=320 0 0
EOF</code></pre>
<p>Make sure you adjust the paths and bitrate, if necessary.</p>
<p>Finally, mount the mp3fs:</p>
<pre><code>$ sudo mount -a</code></pre>
<p>Now your music collection should appear at <code>~/MP3</code> in MP3 format.</p>
<h2 id="configuring-the-client">Configuring the client</h2>
<p>We’re going to use sshfs to stream the music. It uses SSH to allow you to mount remote filesystems on the local machine. In other words, it will make your remote music collection available on the client machine. To start, install sshfs.</p>
<pre><code>$ sudo aptitude install sshfs</code></pre>
<p>Now, mount the remote music collection (adjust the parameters as necessary):</p>
<pre><code>$ sshfs USER@example.com:Music ~/Music</code></pre>
<p>Your music collection should now be visible on the client at <code>~/Music</code>. Fire up your favorite media player, allow it to scan your music library, and enjoy.</p>
<p>If you want the sshfs to be automatically mounted, you will first need to <a href="http://www.ece.uci.edu/~chou/ssh-key.html">set up key-based SSH authentication</a>. Once that’s done, you will need to edit <code>/etc/fstab</code>:</p>
<pre><code># cat &gt;&gt; /etc/fstab &lt;&lt; EOF
sshfs#USER@example.com:Music /home/USER/Music fuse defaults,idmap=user 0 0
EOF</code></pre>
<p>Now your music collection will be available at login.</p>]]></summary>
</entry>
<entry>
    <title>Generate Audio with Python</title>
    <link href="http://noisehack.com/generate-audio-with-python/" />
    <id>http://noisehack.com/generate-audio-with-python/</id>
    <published>2011-04-23T00:00:00Z</published>
    <updated>2011-04-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I’ve been intrigued by the concept of using computers to generate audio for a long time. It turns out that you can generate audio with nothing but the standard library of Python.</p>
<p>The approach I used relies heavily on the <code>itertools</code> module. Essentially, I use <code>itertools</code> to create infinite generators and then take some data from these generators to produce the audio. The resultant sequence of floats in the range [-1.0, 1.0] is converted to 16 bit PCM audio (i.e., a sequence of signed 16 bit integers in the range [-32767, 32767]) and then written to a .wav file using the <code>wave</code> module. <!--more--></p>
<p>If you’re not familiar with iterators and the <code>itertools</code> module, this post may be somewhat hard to follow. <code>itertools</code> really opens up some interesting possibilities in Python, making it more like Lisp or Haskell. In truth, if you’re relying on <code>itertools</code> as much as I am in this post, you might as well just use Lisp or Haskell and receive a nice performance boost. The reason I didn’t is quite simply because I wanted to generate some audio in Python.</p>
<p>To follow the code examples below, you probably need to perform the following imports:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> sys
<span class="ch">import</span> wave
<span class="ch">import</span> math
<span class="ch">import</span> struct
<span class="ch">import</span> random
<span class="ch">import</span> argparse
<span class="ch">from</span> itertools <span class="ch">import</span> *</code></pre>
<h2 id="generating-waves">Generating Waves</h2>
<p>You may remember from your physics class that sound consists of waves. Many instruments produce tones that are basically a combination of pure sine waves. Thus, we need a way to produce sine waves if we want to generate audio. My first approach was something like this:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> sine_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
	<span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
	<span class="kw">return</span> (<span class="dt">float</span>(amplitude) * math.sin(<span class="fl">2.0</span>*math.pi*<span class="dt">float</span>(frequency)*(<span class="dt">float</span>(i)/<span class="dt">float</span>(framerate))) <span class="kw">for</span> i in count(<span class="dv">0</span>))</code></pre>
<p>This computes a sine wave of infinite length at the specified frequency, and returns an infinite generator which samples the wave 44,100 times per second.</p>
<p>The problem with this approach is that it is inefficient. Sine waves are periodic functions, meaning that they repeat themselves after a certain period. This means that we can pre-calculate the function for one period, and then return an iterator which simply cycles these pre-computed values indefinitely:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> sine_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
    period = <span class="dt">int</span>(framerate / frequency)
    <span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
    lookup_table = [<span class="dt">float</span>(amplitude) * math.sin(<span class="fl">2.0</span>*math.pi*<span class="dt">float</span>(frequency)*(<span class="dt">float</span>(i%period)/<span class="dt">float</span>(framerate))) <span class="kw">for</span> i in <span class="dt">xrange</span>(period)]
    <span class="kw">return</span> (lookup_table[i%period] <span class="kw">for</span> i in count(<span class="dv">0</span>))</code></pre>
<p>This resulted in a substantial performance improvement on my machine, but this is Python after all so a discussion of performance is perhaps a moot point.</p>
<h2 id="generating-noise">Generating Noise</h2>
<p>Sometimes you want to generate noise. The simplest kind of noise is called white noise, which is completely random audio data.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> white_noise(amplitude=<span class="fl">0.5</span>):
    <span class="kw">return</span> (<span class="dt">float</span>(amplitude) * random.uniform(-<span class="dv">1</span>, <span class="dv">1</span>) <span class="kw">for</span> _ in count(<span class="dv">0</span>))</code></pre>
<p>The main downside to this approach is that random values need to be calculated 44,100 times per second. Using the <code>itertools</code> module, we can pre-calculate one second of white noise, and then just cycle that data:</p>
<pre class="sourceCode python"><code class="sourceCode python">noise = cycle(islice(white_noise(), <span class="dv">44100</span>))</code></pre>
<h2 id="combining-functions">Combining Functions</h2>
<p>As I mentioned earlier, complex sounds can be modeled as combinations of pure sine waves. If you’re generating a stereo audio file, you can have different audio functions in each channel. The way I chose to represent this concept is as follows:</p>
<pre class="sourceCode python"><code class="sourceCode python">c1 = (f1, ..., fn)
c2 = (f1, ..., fn)
channels = (c1, c2)</code></pre>
<p><code>c1</code> is the left channel, <code>c2</code> is the right channel. Each channel is an iterable containing the functions that comprise that channel. All channels are then combined into a single iterable, <code>channels</code>.</p>
<p>If you play the same sound through both channels of a stereo audio file, the sound will seem to come from the center of the soundstage.</p>
<pre class="sourceCode python"><code class="sourceCode python">channels = ((sine_wave(<span class="fl">440.0</span>),),
			(sine_wave(<span class="fl">440.0</span>),))</code></pre>
<p>You can also control the location of the sound by altering the amplitude of the waves. This example will make a 440.0 Hz sine wave which is slightly left of center:</p>
<pre class="sourceCode python"><code class="sourceCode python">channels = ((sine_wave(<span class="fl">440.0</span>, amplitude=<span class="fl">0.5</span>),),
			(sine_wave(<span class="fl">440.0</span>, amplitude=<span class="fl">0.2</span>),))</code></pre>
<p>Additionally, you can have more than one function playing at the same time. Here’s an example of a 200.0 Hz tone in the left channel, a 205.0 tone in the right channel, and some white noise in the background:</p>
<pre class="sourceCode python"><code class="sourceCode python">channels = ((sine_wave(<span class="fl">200.0</span>, amplitude=<span class="fl">0.1</span>), white_noise(amplitude=<span class="fl">0.001</span>)),
			(sine_wave(<span class="fl">205.0</span>, amplitude=<span class="fl">0.1</span>), white_noise(amplitude=<span class="fl">0.001</span>)))</code></pre>
<p>That’s a <a href="http://en.wikipedia.org/wiki/Binaural_beats">binaural beat</a>.</p>
<h2 id="computing-samples">Computing Samples</h2>
<p>Recall from your physics class that waves combine with each other to produce new waves. We can compute this new wave by simply adding the waves together.</p>
<p>Now that we have defined the audio channels, we need to compute the sum of the functions in the channel at each sample in the file. Since our waves are represented as generators, we want to create a new generator which calculates the sum of each sample in the input generators. Essentially we want a function that accepts audio channels in the format described above and returns a generator which yields tuples where element 0 is the sum of the functions in the left channel at that point, and element 1 is the sum of the functions in the right channel at that point.</p>
<p>This calls for use of the <code>imap</code> and <code>izip</code> functions.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> compute_samples(channels, nsamples=<span class="ot">None</span>):
    <span class="kw">return</span> islice(izip(*(imap(<span class="dt">sum</span>, izip(*channel)) <span class="kw">for</span> channel in channels)), nsamples)</code></pre>
<p>Note that if <code>nsamples</code> is specified, we return a sequence of finite length (using the <code>islice</code> function). Otherwise, we return a sequence of infinite length. Since we are using iterators, sequences of infinite length can be represented more or less elegantly and efficiently.</p>
<h2 id="writing-a-wavefile">Writing a Wavefile</h2>
<p>The next step is to use the <code>wave</code> module to create a <code>.wav</code> file. The first thing to do is to generate the wave header, which is some information at the beginning of the wavefile that describes the contents of the file. The information we need to generate this header is as follows:</p>
<ul>
<li><code>nchannels</code> - the number of channels contained in the file. For stereo, this is 2.</li>
<li><code>sampwidth</code> - the size of each sample, in bytes. Recall that a byte is 8 bits, so for 16 bit audio this is 2.</li>
<li><code>framerate</code> - the number of samples per second. I usually set this to 44100 (CD quality).</li>
<li><code>nframes</code> - the total number of samples to write. This is equal to the framerate multiplied by the duration of the file in seconds.</li>
</ul>
<p>To open a wavefile for writing with the <code>wave</code> module, do this:</p>
<pre class="sourceCode python"><code class="sourceCode python">w = wave.<span class="dt">open</span>(filename, <span class="st">&#39;w&#39;</span>)
w.setparams((nchannels, sampwidth, framerate, nframes, <span class="st">&#39;NONE&#39;</span>, <span class="st">&#39;not compressed&#39;</span>))</code></pre>
<p>The <code>'NONE'</code> and <code>'not compressed'</code> just indicate that we are creating an uncompressed wavefile (nothing else is supported by the <code>wave</code> module at the time of writing).</p>
<p>Now the wavefile is ready for our audio data. 16 bit audio is encoded as a series of signed 16 bit integers. The first thing to do is to scale our sequence of floats in the range [-1.0, 1.0] to signed 16 bit integers (in the range [-32767, 32767]). For example:</p>
<pre class="sourceCode python"><code class="sourceCode python">max_amplitude = <span class="fl">32767.0</span>
samples = (<span class="dt">int</span>(sample * max_amplitude) <span class="kw">for</span> sample in samples)</code></pre>
<p>We’re writing a binary format, so we need the <code>struct</code> module to convert our audio data to the correct binary encoding. Specifically, we need the <code>struct.pack</code> function. The <code>struct.pack</code> function uses format strings to designate how to pack the data. A signed 16 bit integer is also known as a signed short, so we want to use the format string ‘h’ (the format string for a signed short). Thus, to pack the integer 1000 into a signed short:</p>
<pre class="sourceCode python"><code class="sourceCode python">struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dv">1000</span>)</code></pre>
<p>Now, we are going to be creating stereo audio files, so we need to consider how <code>.wav</code> files represent multiple channels. It turns out that <code>.wav</code> files look something like this:</p>
<pre><code>L1R1L2R2L3R3L4R4</code></pre>
<p>Where <code>L1</code> is the first sample in the left channel, <code>R1</code> is the first sample in the right channel, and so on. In other words, the channels are interleaved.</p>
<p>Finally, we want to keep performance in mind. On one extreme, we write data to the file every time we compute a sample. This is memory-efficient, but incurs a severe performance penalty due to the overhead of writing to the file. On the other extreme, we pre-compute the entire file and write all of the samples at once. This does not incur the aforementioned performance penalty, but it has two major problems. First, it requires a huge amount of memory, since the entire <code>.wav</code> file will be loaded into memory. Second, it means you can’t stream the audio as it is generated, which means you can’t play the audio in realtime (by writing to <code>stdout</code> and piping to <code>aplay</code>, for example).</p>
<p>Thus, we take the third approach: buffer chunks of the audio stream and write each chunk as it is computed. This offers the advantages of both techniques.</p>
<p>So, putting all of this together, we end up with something like this:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> grouper(n, iterable, fillvalue=<span class="ot">None</span>):
    <span class="co">&quot;grouper(3, &#39;ABCDEFG&#39;, &#39;x&#39;) --&gt; ABC DEF Gxx&quot;</span>
    args = [<span class="dt">iter</span>(iterable)] * n
    <span class="kw">return</span> izip_longest(fillvalue=fillvalue, *args)

<span class="kw">def</span> write_wavefile(filename, samples, nframes=<span class="ot">None</span>, nchannels=<span class="dv">2</span>, sampwidth=<span class="dv">2</span>, framerate=<span class="dv">44100</span>, bufsize=<span class="dv">2048</span>):
    <span class="kw">if</span> nframes is <span class="ot">None</span>:
        nframes = -<span class="dv">1</span>
	
    w = wave.<span class="dt">open</span>(filename, <span class="st">&#39;w&#39;</span>)
    w.setparams((nchannels, sampwidth, framerate, nframes, <span class="st">&#39;NONE&#39;</span>, <span class="st">&#39;not compressed&#39;</span>))

    max_amplitude = <span class="dt">float</span>(<span class="dt">int</span>((<span class="dv">2</span> ** (sampwidth * <span class="dv">8</span>)) / <span class="dv">2</span>) - <span class="dv">1</span>)

    <span class="co"># split the samples into chunks (to reduce memory consumption and improve performance)</span>
    <span class="kw">for</span> chunk in grouper(bufsize, samples):
        frames = <span class="st">&#39;&#39;</span>.join(<span class="st">&#39;&#39;</span>.join(struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dt">int</span>(max_amplitude * sample)) <span class="kw">for</span> sample in channels) <span class="kw">for</span> channels in chunk <span class="kw">if</span> channels is not <span class="ot">None</span>)
        w.writeframesraw(frames)
    
    w.close()

    <span class="kw">return</span> filename</code></pre>
<h2 id="wavebender">wavebender</h2>
<p>I have compiled these techniques and a few others into a module called <code>wavebender</code>. Here’s the current source code (at the time of writing), but you can always find the latest at <a href="https://github.com/zacharydenton/wavebender">https://github.com/zacharydenton/wavebender</a>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="ch">import</span> sys
<span class="ch">import</span> wave
<span class="ch">import</span> math
<span class="ch">import</span> struct
<span class="ch">import</span> random
<span class="ch">import</span> argparse
<span class="ch">from</span> itertools <span class="ch">import</span> *

<span class="kw">def</span> grouper(n, iterable, fillvalue=<span class="ot">None</span>):
    <span class="co">&quot;grouper(3, &#39;ABCDEFG&#39;, &#39;x&#39;) --&gt; ABC DEF Gxx&quot;</span>
    args = [<span class="dt">iter</span>(iterable)] * n
    <span class="kw">return</span> izip_longest(fillvalue=fillvalue, *args)

<span class="kw">def</span> sine_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    Generate a sine wave at a given frequency of infinite length.</span>
<span class="co">    &#39;&#39;&#39;</span>
    period = <span class="dt">int</span>(framerate / frequency)
    <span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
    lookup_table = [<span class="dt">float</span>(amplitude) * math.sin(<span class="fl">2.0</span>*math.pi*<span class="dt">float</span>(frequency)*(<span class="dt">float</span>(i%period)/<span class="dt">float</span>(framerate))) <span class="kw">for</span> i in <span class="dt">xrange</span>(period)]
    <span class="kw">return</span> (lookup_table[i%period] <span class="kw">for</span> i in count(<span class="dv">0</span>))

<span class="kw">def</span> square_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
    <span class="kw">for</span> s in sine_wave(frequency, framerate, amplitude):
        <span class="kw">if</span> s &gt; <span class="dv">0</span>:
            <span class="kw">yield</span> amplitude
        <span class="kw">elif</span> s &lt; <span class="dv">0</span>:
            <span class="kw">yield</span> -amplitude
        <span class="kw">else</span>:
            <span class="kw">yield</span> <span class="fl">0.0</span>

<span class="kw">def</span> damped_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>, length=<span class="dv">44100</span>):
    <span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
    <span class="kw">return</span> (math.exp(-(<span class="dt">float</span>(i%length)/<span class="dt">float</span>(framerate))) * s <span class="kw">for</span> i, s in <span class="dt">enumerate</span>(sine_wave(frequency, framerate, amplitude)))

<span class="kw">def</span> white_noise(amplitude=<span class="fl">0.5</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    Generate random samples.</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">return</span> (<span class="dt">float</span>(amplitude) * random.uniform(-<span class="dv">1</span>, <span class="dv">1</span>) <span class="kw">for</span> i in count(<span class="dv">0</span>))

<span class="kw">def</span> compute_samples(channels, nsamples=<span class="ot">None</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    create a generator which computes the samples.</span>

<span class="co">    essentially it creates a sequence of the sum of each function in the channel</span>
<span class="co">    at each sample in the file for each channel.</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">return</span> islice(izip(*(imap(<span class="dt">sum</span>, izip(*channel)) <span class="kw">for</span> channel in channels)), nsamples)

<span class="kw">def</span> write_wavefile(filename, samples, nframes=<span class="ot">None</span>, nchannels=<span class="dv">2</span>, sampwidth=<span class="dv">2</span>, framerate=<span class="dv">44100</span>, bufsize=<span class="dv">2048</span>):
    <span class="co">&quot;Write samples to a wavefile.&quot;</span>
    <span class="kw">if</span> nframes is <span class="ot">None</span>:
        nframes = -<span class="dv">1</span>

    w = wave.<span class="dt">open</span>(filename, <span class="st">&#39;w&#39;</span>)
    w.setparams((nchannels, sampwidth, framerate, nframes, <span class="st">&#39;NONE&#39;</span>, <span class="st">&#39;not compressed&#39;</span>))

    max_amplitude = <span class="dt">float</span>(<span class="dt">int</span>((<span class="dv">2</span> ** (sampwidth * <span class="dv">8</span>)) / <span class="dv">2</span>) - <span class="dv">1</span>)

    <span class="co"># split the samples into chunks (to reduce memory consumption and improve performance)</span>
    <span class="kw">for</span> chunk in grouper(bufsize, samples):
        frames = <span class="st">&#39;&#39;</span>.join(<span class="st">&#39;&#39;</span>.join(struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dt">int</span>(max_amplitude * sample)) <span class="kw">for</span> sample in channels) <span class="kw">for</span> channels in chunk <span class="kw">if</span> channels is not <span class="ot">None</span>)
        w.writeframesraw(frames)
    
    w.close()

    <span class="kw">return</span> filename

<span class="kw">def</span> write_pcm(f, samples, sampwidth=<span class="dv">2</span>, framerate=<span class="dv">44100</span>, bufsize=<span class="dv">2048</span>):
    <span class="co">&quot;Write samples as raw PCM data.&quot;</span>
    max_amplitude = <span class="dt">float</span>(<span class="dt">int</span>((<span class="dv">2</span> ** (sampwidth * <span class="dv">8</span>)) / <span class="dv">2</span>) - <span class="dv">1</span>)

    <span class="co"># split the samples into chunks (to reduce memory consumption and improve performance)</span>
    <span class="kw">for</span> chunk in grouper(bufsize, samples):
        frames = <span class="st">&#39;&#39;</span>.join(<span class="st">&#39;&#39;</span>.join(struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dt">int</span>(max_amplitude * sample)) <span class="kw">for</span> sample in channels) <span class="kw">for</span> channels in chunk <span class="kw">if</span> channels is not <span class="ot">None</span>)
        f.write(frames)
    
    f.close()

    <span class="kw">return</span> filename

<span class="kw">def</span> main():
    parser = argparse.ArgumentParser()
    parser.add_argument(<span class="st">&#39;-c&#39;</span>, <span class="st">&#39;--channels&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Number of channels to produce&quot;</span>, default=<span class="dv">2</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-b&#39;</span>, <span class="st">&#39;--bits&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Number of bits in each sample&quot;</span>, choices=(<span class="dv">16</span>,), default=<span class="dv">16</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-r&#39;</span>, <span class="st">&#39;--rate&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Sample rate in Hz&quot;</span>, default=<span class="dv">44100</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-t&#39;</span>, <span class="st">&#39;--time&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Duration of the wave in seconds.&quot;</span>, default=<span class="dv">60</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-a&#39;</span>, <span class="st">&#39;--amplitude&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Amplitude of the wave on a scale of 0.0-1.0.&quot;</span>, default=<span class="fl">0.5</span>, <span class="dt">type</span>=<span class="dt">float</span>)
    parser.add_argument(<span class="st">&#39;-f&#39;</span>, <span class="st">&#39;--frequency&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Frequency of the wave in Hz&quot;</span>, default=<span class="fl">440.0</span>, <span class="dt">type</span>=<span class="dt">float</span>)
    parser.add_argument(<span class="st">&#39;filename&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;The file to generate.&quot;</span>)
    args = parser.parse_args()

    <span class="co"># each channel is defined by infinite functions which are added to produce a sample.</span>
    channels = ((sine_wave(args.frequency, args.rate, args.amplitude),) <span class="kw">for</span> i in <span class="dt">range</span>(args.channels))

    <span class="co"># convert the channel functions into waveforms</span>
    samples = compute_samples(channels, args.rate * args.time)

    <span class="co"># write the samples to a file</span>
    <span class="kw">if</span> args.filename == <span class="st">&#39;-&#39;</span>:
        filename = sys.stdout
    <span class="kw">else</span>:
        filename = args.filename
    write_wavefile(filename, samples, args.rate * args.time, args.channels, args.bits / <span class="dv">8</span>, args.rate)

<span class="kw">if</span> <span class="dt">__name__</span> == <span class="st">&quot;__main__&quot;</span>:
    main()</code></pre>
<p>You can execute the file directly and it will generate a pure sine tone.</p>
<h2 id="examples">Examples</h2>
<h3 id="sbagen">SBaGen</h3>
<p><a href="http://uazu.net/sbagen/">SBaGen</a> is a program which generates binaural beats. It’s reasonably complex, consisting of around 3000 lines of C. You can instruct SBaGen to generate a 200Hz pure sine tone in one channel and a 204Hz pure sine tone in the other channel by doing this:</p>
<pre class="console"><code>$ sbagen -i 202+2/10</code></pre>
<p>You can also generate multiple binaural beats simultaneously:</p>
<pre class="console"><code>$ sbagen -i 202+2/10 400+20/10</code></pre>
<p>The following emulates <code>sbagen -i</code>, but it’s about 100x slower. No problem for real-time use on a modern computer, but you’re better off using the real deal for serious use.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="ch">import</span> re
<span class="ch">import</span> sys
<span class="ch">from</span> wavebender <span class="ch">import</span> *
<span class="ch">from</span> itertools <span class="ch">import</span> *

<span class="kw">def</span> sbagen_phrase(phrase):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    147.0+4.0/1.27 -&gt; two sine_waves. one 145.0 hz; one 149.0 hz. each at amplitude of 0.0127.</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">if</span> <span class="st">&#39;pink&#39;</span> in phrase:
		<span class="co"># pink/40 -&gt; white_noise(amplitude=0.4)</span>
        amplitude = <span class="dt">float</span>(phrase.split(<span class="st">&#39;/&#39;</span>)[-<span class="dv">1</span>]) / <span class="fl">100.0</span>
        <span class="kw">return</span> (white_noise(amplitude),
                white_noise(amplitude))

    carrier, remainder = re.split(<span class="st">&#39;[+-]&#39;</span>, phrase, <span class="dv">1</span>)
    beatfreq, amplitude = remainder.split(<span class="st">&#39;/&#39;</span>)

    carrier = <span class="dt">float</span>(carrier)
    beatfreq = <span class="dt">float</span>(beatfreq)
    amplitude = <span class="dt">float</span>(amplitude) / <span class="fl">100.0</span>

    <span class="kw">return</span> (sine_wave((carrier - beatfreq/<span class="dv">2</span>), amplitude=amplitude),
            sine_wave((carrier + beatfreq/<span class="dv">2</span>), amplitude=amplitude))

<span class="kw">def</span> sbagen_line(line, length=<span class="ot">None</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    Given a sequence of (l, r), (l, r), return a sequence of (l, l), (r, r).</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">return</span> izip(*(imap(<span class="kw">lambda</span> s: islice(s, length), sbagen_phrase(phrase)) <span class="kw">for</span> phrase in line.split()))

<span class="kw">if</span> sys.argv[<span class="dv">1</span>:]:
    channels = sbagen_line(<span class="st">&#39; &#39;</span>.join(sys.argv[<span class="dv">1</span>:]))
<span class="kw">else</span>:
    sys.exit(<span class="dv">1</span>)

samples = compute_samples(channels)
write_wavefile(sys.stdout, samples)</code></pre>
<p>You can use it like this:</p>
<pre class="console"><code>$ ./sbagen.py 272.2+7.83/10 332+7.83/10 421.3+7.83/10 289.4+7.83/10 367.5+7.83/10 442+7.83/10 295.7+7.83/10 414.7+7.83/10 422+7.83/10 | aplay</code></pre>
<p>That generates a bunch of simultaneous binaural tones and uses <code>aplay</code> to play them in realtime.</p>
<h3 id="melody">Melody</h3>
<p>Here’s an example of a melody, using <code>itertools</code> and <code>wavebender</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="ch">from</span> wavebender <span class="ch">import</span> *
<span class="ch">from</span> itertools <span class="ch">import</span> *
<span class="ch">import</span> sys

<span class="kw">def</span> ncycles(iterable, n):
    <span class="co">&quot;Returns the sequence elements n times&quot;</span>
    <span class="kw">return</span> chain.from_iterable(repeat(<span class="dt">tuple</span>(iterable), n))

<span class="kw">def</span> waves():
    l = <span class="dt">int</span>(<span class="dv">44100</span>*<span class="fl">0.4</span>) <span class="co"># each note lasts 0.4 seconds</span>
    
    <span class="kw">return</span> cycle(chain(ncycles(chain(islice(damped_wave(frequency=<span class="fl">440.0</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">261.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">329.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l)), <span class="dv">3</span>),
                       islice(damped_wave(frequency=<span class="fl">440.0</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dv">3</span>*l), <span class="dv">3</span>*l),
                 
                       ncycles(chain(islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">261.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l)), <span class="dv">2</span>),
                       chain(islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                             islice(damped_wave(frequency=<span class="fl">329.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                             islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l)),
                       islice(damped_wave(frequency=<span class="fl">261.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dv">3</span>*l), <span class="dv">3</span>*l)))

channels = ((waves(),), (waves(), white_noise(amplitude=<span class="fl">0.001</span>),))

samples = compute_samples(channels, <span class="ot">None</span>)
write_wavefile(sys.stdout, samples, <span class="ot">None</span>)</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Well, there’s your daily abuse of <code>itertools</code>. For more <code>itertools</code> madness, check out my <a href="/project-euler-solutions/">Project Euler Solutions</a>.</p>]]></summary>
</entry>

</feed>
