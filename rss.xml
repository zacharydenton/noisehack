<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Noisehack</title>
    <link href="http://noisehack.com/rss.xml" rel="self" />
    <link href="http://noisehack.com" />
    <id>http://noisehack.com/rss.xml</id>
    <author>
        <name>Zach Denton</name>
        <email>z@chdenton.com</email>
    </author>
    <updated>2011-12-29T00:00:00Z</updated>
    <entry>
    <title>Music Server Revisited: Streaming with sshfs and mp3fs</title>
    <link href="http://noisehack.com/music-server-revisited-streaming-with-sshfs-and-mp3fs/" />
    <id>http://noisehack.com/music-server-revisited-streaming-with-sshfs-and-mp3fs/</id>
    <published>2011-12-29T00:00:00Z</published>
    <updated>2011-12-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A while back, I wrote about <a href="/build-a-media-server-with-ampache-and-transmission/">streaming music with Ampache</a>. Ampache is a nice piece of software, with some unique advantages (like Android support). However, there are simpler ways to stream music. I’m going to show you how to stream music using sshfs and (optionally) mp3fs. One of the best things about this approach is that it allows you to access your collection with the media player of your choice.</p>
<!--more-->

<p>Before you start, you’re going to need a Linux machine with your music collection on it (the server). You will also need another Linux machine to act as the client (e.g. a laptop with a small hard drive).</p>
<h2 id="configuring-the-server">Configuring the server</h2>
<h3 id="install-the-ssh-server">Install the ssh server</h3>
<p>The first thing you’re going to want to do is install an ssh server, if it’s not already installed.</p>
<pre><code>$ sudo aptitude install openssh-server</code></pre>
<p>If your music is already compressed, or if you just have a very fast internet connection, you’re done configuring the server. Otherwise, read on to learn how to transcode your music on-the-fly with mp3fs.</p>
<h3 id="set-up-mp3fs">Set up mp3fs</h3>
<blockquote>
<p>MP3FS is a read-only FUSE filesystem which transcodes audio formats (currently FLAC) to MP3 on the fly when opened and read. This was written to enable me to use my FLAC collection with software and/or hardware which only understands the MP3 format e.g. gmediaserver to a Netgear MP101 MP3 player. — <a href="http://khenriks.github.com/mp3fs/">Kristofer Henriksson</a></p>
</blockquote>
<p>If you have any music in FLAC format, you’re probably not going to be able to stream it without first transcoding to MP3. mp3fs solves this problem. First, install it.</p>
<pre><code>$ sudo aptitude install mp3fs</code></pre>
<p>NOTE: Depending on your distro, the repositories might have an outdated version of mp3fs. If the following commands don’t work, try installing a newer version of mp3fs (either by compiling it yourself or finding a newer package).</p>
<p>Now that it’s installed, we’ll set it up. Create a folder for the mp3fs:</p>
<pre><code>$ mkdir ~/MP3</code></pre>
<p>Next, add an entry to <code>/etc/fstab</code> to automatically mount the mp3fs:</p>
<pre><code># cat &gt;&gt; /etc/fstab &lt;&lt; EOF
mp3fs#/home/USER/Music /home/USER/MP3 fuse allow_other,ro,bitrate=320 0 0
EOF</code></pre>
<p>Make sure you adjust the paths and bitrate, if necessary.</p>
<p>Finally, mount the mp3fs:</p>
<pre><code>$ sudo mount -a</code></pre>
<p>Now your music collection should appear at <code>~/MP3</code> in MP3 format.</p>
<h2 id="configuring-the-client">Configuring the client</h2>
<p>We’re going to use sshfs to stream the music. It uses SSH to allow you to mount remote filesystems on the local machine. In other words, it will make your remote music collection available on the client machine. To start, install sshfs.</p>
<pre><code>$ sudo aptitude install sshfs</code></pre>
<p>Now, mount the remote music collection (adjust the parameters as necessary):</p>
<pre><code>$ sshfs USER@example.com:Music ~/Music</code></pre>
<p>Your music collection should now be visible on the client at <code>~/Music</code>. Fire up your favorite media player, allow it to scan your music library, and enjoy.</p>
<p>If you want the sshfs to be automatically mounted, you will first need to <a href="http://www.ece.uci.edu/~chou/ssh-key.html">set up key-based SSH authentication</a>. Once that’s done, you will need to edit <code>/etc/fstab</code>:</p>
<pre><code># cat &gt;&gt; /etc/fstab &lt;&lt; EOF
sshfs#USER@example.com:Music /home/USER/Music fuse defaults,idmap=user 0 0
EOF</code></pre>
<p>Now your music collection will be available at login.</p>]]></summary>
</entry>
<entry>
    <title>Generate Audio with Python</title>
    <link href="http://noisehack.com/generate-audio-with-python/" />
    <id>http://noisehack.com/generate-audio-with-python/</id>
    <published>2011-04-23T00:00:00Z</published>
    <updated>2011-04-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I’ve been intrigued by the concept of using computers to generate audio for a long time. It turns out that you can generate audio with nothing but the standard library of Python.</p>
<p>The approach I used relies heavily on the <code>itertools</code> module. Essentially, I use <code>itertools</code> to create infinite generators and then take some data from these generators to produce the audio. The resultant sequence of floats in the range [-1.0, 1.0] is converted to 16 bit PCM audio (i.e., a sequence of signed 16 bit integers in the range [-32767, 32767]) and then written to a .wav file using the <code>wave</code> module. <!--more--></p>
<p>If you’re not familiar with iterators and the <code>itertools</code> module, this post may be somewhat hard to follow. <code>itertools</code> really opens up some interesting possibilities in Python, making it more like Lisp or Haskell. In truth, if you’re relying on <code>itertools</code> as much as I am in this post, you might as well just use Lisp or Haskell and receive a nice performance boost. The reason I didn’t is quite simply because I wanted to generate some audio in Python.</p>
<p>To follow the code examples below, you probably need to perform the following imports:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> sys
<span class="ch">import</span> wave
<span class="ch">import</span> math
<span class="ch">import</span> struct
<span class="ch">import</span> random
<span class="ch">import</span> argparse
<span class="ch">from</span> itertools <span class="ch">import</span> *</code></pre>
<h2 id="generating-waves">Generating Waves</h2>
<p>You may remember from your physics class that sound consists of waves. Many instruments produce tones that are basically a combination of pure sine waves. Thus, we need a way to produce sine waves if we want to generate audio. My first approach was something like this:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> sine_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
	<span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
	<span class="kw">return</span> (<span class="dt">float</span>(amplitude) * math.sin(<span class="fl">2.0</span>*math.pi*<span class="dt">float</span>(frequency)*(<span class="dt">float</span>(i)/<span class="dt">float</span>(framerate))) <span class="kw">for</span> i in count(<span class="dv">0</span>))</code></pre>
<p>This computes a sine wave of infinite length at the specified frequency, and returns an infinite generator which samples the wave 44,100 times per second.</p>
<p>The problem with this approach is that it is inefficient. Sine waves are periodic functions, meaning that they repeat themselves after a certain period. This means that we can pre-calculate the function for one period, and then return an iterator which simply cycles these pre-computed values indefinitely:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> sine_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
    period = <span class="dt">int</span>(framerate / frequency)
    <span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
    lookup_table = [<span class="dt">float</span>(amplitude) * math.sin(<span class="fl">2.0</span>*math.pi*<span class="dt">float</span>(frequency)*(<span class="dt">float</span>(i%period)/<span class="dt">float</span>(framerate))) <span class="kw">for</span> i in <span class="dt">xrange</span>(period)]
    <span class="kw">return</span> (lookup_table[i%period] <span class="kw">for</span> i in count(<span class="dv">0</span>))</code></pre>
<p>This resulted in a substantial performance improvement on my machine, but this is Python after all so a discussion of performance is perhaps a moot point.</p>
<h2 id="generating-noise">Generating Noise</h2>
<p>Sometimes you want to generate noise. The simplest kind of noise is called white noise, which is completely random audio data.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> white_noise(amplitude=<span class="fl">0.5</span>):
    <span class="kw">return</span> (<span class="dt">float</span>(amplitude) * random.uniform(-<span class="dv">1</span>, <span class="dv">1</span>) <span class="kw">for</span> _ in count(<span class="dv">0</span>))</code></pre>
<p>The main downside to this approach is that random values need to be calculated 44,100 times per second. Using the <code>itertools</code> module, we can pre-calculate one second of white noise, and then just cycle that data:</p>
<pre class="sourceCode python"><code class="sourceCode python">noise = cycle(islice(white_noise(), <span class="dv">44100</span>))</code></pre>
<h2 id="combining-functions">Combining Functions</h2>
<p>As I mentioned earlier, complex sounds can be modeled as combinations of pure sine waves. If you’re generating a stereo audio file, you can have different audio functions in each channel. The way I chose to represent this concept is as follows:</p>
<pre class="sourceCode python"><code class="sourceCode python">c1 = (f1, ..., fn)
c2 = (f1, ..., fn)
channels = (c1, c2)</code></pre>
<p><code>c1</code> is the left channel, <code>c2</code> is the right channel. Each channel is an iterable containing the functions that comprise that channel. All channels are then combined into a single iterable, <code>channels</code>.</p>
<p>If you play the same sound through both channels of a stereo audio file, the sound will seem to come from the center of the soundstage.</p>
<pre class="sourceCode python"><code class="sourceCode python">channels = ((sine_wave(<span class="fl">440.0</span>),),
			(sine_wave(<span class="fl">440.0</span>),))</code></pre>
<p>You can also control the location of the sound by altering the amplitude of the waves. This example will make a 440.0 Hz sine wave which is slightly left of center:</p>
<pre class="sourceCode python"><code class="sourceCode python">channels = ((sine_wave(<span class="fl">440.0</span>, amplitude=<span class="fl">0.5</span>),),
			(sine_wave(<span class="fl">440.0</span>, amplitude=<span class="fl">0.2</span>),))</code></pre>
<p>Additionally, you can have more than one function playing at the same time. Here’s an example of a 200.0 Hz tone in the left channel, a 205.0 tone in the right channel, and some white noise in the background:</p>
<pre class="sourceCode python"><code class="sourceCode python">channels = ((sine_wave(<span class="fl">200.0</span>, amplitude=<span class="fl">0.1</span>), white_noise(amplitude=<span class="fl">0.001</span>)),
			(sine_wave(<span class="fl">205.0</span>, amplitude=<span class="fl">0.1</span>), white_noise(amplitude=<span class="fl">0.001</span>)))</code></pre>
<p>That’s a <a href="http://en.wikipedia.org/wiki/Binaural_beats">binaural beat</a>.</p>
<h2 id="computing-samples">Computing Samples</h2>
<p>Recall from your physics class that waves combine with each other to produce new waves. We can compute this new wave by simply adding the waves together.</p>
<p>Now that we have defined the audio channels, we need to compute the sum of the functions in the channel at each sample in the file. Since our waves are represented as generators, we want to create a new generator which calculates the sum of each sample in the input generators. Essentially we want a function that accepts audio channels in the format described above and returns a generator which yields tuples where element 0 is the sum of the functions in the left channel at that point, and element 1 is the sum of the functions in the right channel at that point.</p>
<p>This calls for use of the <code>imap</code> and <code>izip</code> functions.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> compute_samples(channels, nsamples=<span class="ot">None</span>):
    <span class="kw">return</span> islice(izip(*(imap(<span class="dt">sum</span>, izip(*channel)) <span class="kw">for</span> channel in channels)), nsamples)</code></pre>
<p>Note that if <code>nsamples</code> is specified, we return a sequence of finite length (using the <code>islice</code> function). Otherwise, we return a sequence of infinite length. Since we are using iterators, sequences of infinite length can be represented more or less elegantly and efficiently.</p>
<h2 id="writing-a-wavefile">Writing a Wavefile</h2>
<p>The next step is to use the <code>wave</code> module to create a <code>.wav</code> file. The first thing to do is to generate the wave header, which is some information at the beginning of the wavefile that describes the contents of the file. The information we need to generate this header is as follows:</p>
<ul>
<li><code>nchannels</code> - the number of channels contained in the file. For stereo, this is 2.</li>
<li><code>sampwidth</code> - the size of each sample, in bytes. Recall that a byte is 8 bits, so for 16 bit audio this is 2.</li>
<li><code>framerate</code> - the number of samples per second. I usually set this to 44100 (CD quality).</li>
<li><code>nframes</code> - the total number of samples to write. This is equal to the framerate multiplied by the duration of the file in seconds.</li>
</ul>
<p>To open a wavefile for writing with the <code>wave</code> module, do this:</p>
<pre class="sourceCode python"><code class="sourceCode python">w = wave.<span class="dt">open</span>(filename, <span class="st">&#39;w&#39;</span>)
w.setparams((nchannels, sampwidth, framerate, nframes, <span class="st">&#39;NONE&#39;</span>, <span class="st">&#39;not compressed&#39;</span>))</code></pre>
<p>The <code>'NONE'</code> and <code>'not compressed'</code> just indicate that we are creating an uncompressed wavefile (nothing else is supported by the <code>wave</code> module at the time of writing).</p>
<p>Now the wavefile is ready for our audio data. 16 bit audio is encoded as a series of signed 16 bit integers. The first thing to do is to scale our sequence of floats in the range [-1.0, 1.0] to signed 16 bit integers (in the range [-32767, 32767]). For example:</p>
<pre class="sourceCode python"><code class="sourceCode python">max_amplitude = <span class="fl">32767.0</span>
samples = (<span class="dt">int</span>(sample * max_amplitude) <span class="kw">for</span> sample in samples)</code></pre>
<p>We’re writing a binary format, so we need the <code>struct</code> module to convert our audio data to the correct binary encoding. Specifically, we need the <code>struct.pack</code> function. The <code>struct.pack</code> function uses format strings to designate how to pack the data. A signed 16 bit integer is also known as a signed short, so we want to use the format string ‘h’ (the format string for a signed short). Thus, to pack the integer 1000 into a signed short:</p>
<pre class="sourceCode python"><code class="sourceCode python">struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dv">1000</span>)</code></pre>
<p>Now, we are going to be creating stereo audio files, so we need to consider how <code>.wav</code> files represent multiple channels. It turns out that <code>.wav</code> files look something like this:</p>
<pre><code>L1R1L2R2L3R3L4R4</code></pre>
<p>Where <code>L1</code> is the first sample in the left channel, <code>R1</code> is the first sample in the right channel, and so on. In other words, the channels are interleaved.</p>
<p>Finally, we want to keep performance in mind. On one extreme, we write data to the file every time we compute a sample. This is memory-efficient, but incurs a severe performance penalty due to the overhead of writing to the file. On the other extreme, we pre-compute the entire file and write all of the samples at once. This does not incur the aforementioned performance penalty, but it has two major problems. First, it requires a huge amount of memory, since the entire <code>.wav</code> file will be loaded into memory. Second, it means you can’t stream the audio as it is generated, which means you can’t play the audio in realtime (by writing to <code>stdout</code> and piping to <code>aplay</code>, for example).</p>
<p>Thus, we take the third approach: buffer chunks of the audio stream and write each chunk as it is computed. This offers the advantages of both techniques.</p>
<p>So, putting all of this together, we end up with something like this:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> grouper(n, iterable, fillvalue=<span class="ot">None</span>):
    <span class="co">&quot;grouper(3, &#39;ABCDEFG&#39;, &#39;x&#39;) --&gt; ABC DEF Gxx&quot;</span>
    args = [<span class="dt">iter</span>(iterable)] * n
    <span class="kw">return</span> izip_longest(fillvalue=fillvalue, *args)

<span class="kw">def</span> write_wavefile(filename, samples, nframes=<span class="ot">None</span>, nchannels=<span class="dv">2</span>, sampwidth=<span class="dv">2</span>, framerate=<span class="dv">44100</span>, bufsize=<span class="dv">2048</span>):
    <span class="kw">if</span> nframes is <span class="ot">None</span>:
        nframes = -<span class="dv">1</span>
	
    w = wave.<span class="dt">open</span>(filename, <span class="st">&#39;w&#39;</span>)
    w.setparams((nchannels, sampwidth, framerate, nframes, <span class="st">&#39;NONE&#39;</span>, <span class="st">&#39;not compressed&#39;</span>))

    max_amplitude = <span class="dt">float</span>(<span class="dt">int</span>((<span class="dv">2</span> ** (sampwidth * <span class="dv">8</span>)) / <span class="dv">2</span>) - <span class="dv">1</span>)

    <span class="co"># split the samples into chunks (to reduce memory consumption and improve performance)</span>
    <span class="kw">for</span> chunk in grouper(bufsize, samples):
        frames = <span class="st">&#39;&#39;</span>.join(<span class="st">&#39;&#39;</span>.join(struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dt">int</span>(max_amplitude * sample)) <span class="kw">for</span> sample in channels) <span class="kw">for</span> channels in chunk <span class="kw">if</span> channels is not <span class="ot">None</span>)
        w.writeframesraw(frames)
    
    w.close()

    <span class="kw">return</span> filename</code></pre>
<h2 id="wavebender">wavebender</h2>
<p>I have compiled these techniques and a few others into a module called <code>wavebender</code>. Here’s the current source code (at the time of writing), but you can always find the latest at <a href="https://github.com/zacharydenton/wavebender">https://github.com/zacharydenton/wavebender</a>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="ch">import</span> sys
<span class="ch">import</span> wave
<span class="ch">import</span> math
<span class="ch">import</span> struct
<span class="ch">import</span> random
<span class="ch">import</span> argparse
<span class="ch">from</span> itertools <span class="ch">import</span> *

<span class="kw">def</span> grouper(n, iterable, fillvalue=<span class="ot">None</span>):
    <span class="co">&quot;grouper(3, &#39;ABCDEFG&#39;, &#39;x&#39;) --&gt; ABC DEF Gxx&quot;</span>
    args = [<span class="dt">iter</span>(iterable)] * n
    <span class="kw">return</span> izip_longest(fillvalue=fillvalue, *args)

<span class="kw">def</span> sine_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    Generate a sine wave at a given frequency of infinite length.</span>
<span class="co">    &#39;&#39;&#39;</span>
    period = <span class="dt">int</span>(framerate / frequency)
    <span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
    lookup_table = [<span class="dt">float</span>(amplitude) * math.sin(<span class="fl">2.0</span>*math.pi*<span class="dt">float</span>(frequency)*(<span class="dt">float</span>(i%period)/<span class="dt">float</span>(framerate))) <span class="kw">for</span> i in <span class="dt">xrange</span>(period)]
    <span class="kw">return</span> (lookup_table[i%period] <span class="kw">for</span> i in count(<span class="dv">0</span>))

<span class="kw">def</span> square_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>):
    <span class="kw">for</span> s in sine_wave(frequency, framerate, amplitude):
        <span class="kw">if</span> s &gt; <span class="dv">0</span>:
            <span class="kw">yield</span> amplitude
        <span class="kw">elif</span> s &lt; <span class="dv">0</span>:
            <span class="kw">yield</span> -amplitude
        <span class="kw">else</span>:
            <span class="kw">yield</span> <span class="fl">0.0</span>

<span class="kw">def</span> damped_wave(frequency=<span class="fl">440.0</span>, framerate=<span class="dv">44100</span>, amplitude=<span class="fl">0.5</span>, length=<span class="dv">44100</span>):
    <span class="kw">if</span> amplitude &gt; <span class="fl">1.0</span>: amplitude = <span class="fl">1.0</span>
    <span class="kw">if</span> amplitude &lt; <span class="fl">0.0</span>: amplitude = <span class="fl">0.0</span>
    <span class="kw">return</span> (math.exp(-(<span class="dt">float</span>(i%length)/<span class="dt">float</span>(framerate))) * s <span class="kw">for</span> i, s in <span class="dt">enumerate</span>(sine_wave(frequency, framerate, amplitude)))

<span class="kw">def</span> white_noise(amplitude=<span class="fl">0.5</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    Generate random samples.</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">return</span> (<span class="dt">float</span>(amplitude) * random.uniform(-<span class="dv">1</span>, <span class="dv">1</span>) <span class="kw">for</span> i in count(<span class="dv">0</span>))

<span class="kw">def</span> compute_samples(channels, nsamples=<span class="ot">None</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    create a generator which computes the samples.</span>

<span class="co">    essentially it creates a sequence of the sum of each function in the channel</span>
<span class="co">    at each sample in the file for each channel.</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">return</span> islice(izip(*(imap(<span class="dt">sum</span>, izip(*channel)) <span class="kw">for</span> channel in channels)), nsamples)

<span class="kw">def</span> write_wavefile(filename, samples, nframes=<span class="ot">None</span>, nchannels=<span class="dv">2</span>, sampwidth=<span class="dv">2</span>, framerate=<span class="dv">44100</span>, bufsize=<span class="dv">2048</span>):
    <span class="co">&quot;Write samples to a wavefile.&quot;</span>
    <span class="kw">if</span> nframes is <span class="ot">None</span>:
        nframes = -<span class="dv">1</span>

    w = wave.<span class="dt">open</span>(filename, <span class="st">&#39;w&#39;</span>)
    w.setparams((nchannels, sampwidth, framerate, nframes, <span class="st">&#39;NONE&#39;</span>, <span class="st">&#39;not compressed&#39;</span>))

    max_amplitude = <span class="dt">float</span>(<span class="dt">int</span>((<span class="dv">2</span> ** (sampwidth * <span class="dv">8</span>)) / <span class="dv">2</span>) - <span class="dv">1</span>)

    <span class="co"># split the samples into chunks (to reduce memory consumption and improve performance)</span>
    <span class="kw">for</span> chunk in grouper(bufsize, samples):
        frames = <span class="st">&#39;&#39;</span>.join(<span class="st">&#39;&#39;</span>.join(struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dt">int</span>(max_amplitude * sample)) <span class="kw">for</span> sample in channels) <span class="kw">for</span> channels in chunk <span class="kw">if</span> channels is not <span class="ot">None</span>)
        w.writeframesraw(frames)
    
    w.close()

    <span class="kw">return</span> filename

<span class="kw">def</span> write_pcm(f, samples, sampwidth=<span class="dv">2</span>, framerate=<span class="dv">44100</span>, bufsize=<span class="dv">2048</span>):
    <span class="co">&quot;Write samples as raw PCM data.&quot;</span>
    max_amplitude = <span class="dt">float</span>(<span class="dt">int</span>((<span class="dv">2</span> ** (sampwidth * <span class="dv">8</span>)) / <span class="dv">2</span>) - <span class="dv">1</span>)

    <span class="co"># split the samples into chunks (to reduce memory consumption and improve performance)</span>
    <span class="kw">for</span> chunk in grouper(bufsize, samples):
        frames = <span class="st">&#39;&#39;</span>.join(<span class="st">&#39;&#39;</span>.join(struct.pack(<span class="st">&#39;h&#39;</span>, <span class="dt">int</span>(max_amplitude * sample)) <span class="kw">for</span> sample in channels) <span class="kw">for</span> channels in chunk <span class="kw">if</span> channels is not <span class="ot">None</span>)
        f.write(frames)
    
    f.close()

    <span class="kw">return</span> filename

<span class="kw">def</span> main():
    parser = argparse.ArgumentParser()
    parser.add_argument(<span class="st">&#39;-c&#39;</span>, <span class="st">&#39;--channels&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Number of channels to produce&quot;</span>, default=<span class="dv">2</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-b&#39;</span>, <span class="st">&#39;--bits&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Number of bits in each sample&quot;</span>, choices=(<span class="dv">16</span>,), default=<span class="dv">16</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-r&#39;</span>, <span class="st">&#39;--rate&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Sample rate in Hz&quot;</span>, default=<span class="dv">44100</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-t&#39;</span>, <span class="st">&#39;--time&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Duration of the wave in seconds.&quot;</span>, default=<span class="dv">60</span>, <span class="dt">type</span>=<span class="dt">int</span>)
    parser.add_argument(<span class="st">&#39;-a&#39;</span>, <span class="st">&#39;--amplitude&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Amplitude of the wave on a scale of 0.0-1.0.&quot;</span>, default=<span class="fl">0.5</span>, <span class="dt">type</span>=<span class="dt">float</span>)
    parser.add_argument(<span class="st">&#39;-f&#39;</span>, <span class="st">&#39;--frequency&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;Frequency of the wave in Hz&quot;</span>, default=<span class="fl">440.0</span>, <span class="dt">type</span>=<span class="dt">float</span>)
    parser.add_argument(<span class="st">&#39;filename&#39;</span>, <span class="dt">help</span>=<span class="st">&quot;The file to generate.&quot;</span>)
    args = parser.parse_args()

    <span class="co"># each channel is defined by infinite functions which are added to produce a sample.</span>
    channels = ((sine_wave(args.frequency, args.rate, args.amplitude),) <span class="kw">for</span> i in <span class="dt">range</span>(args.channels))

    <span class="co"># convert the channel functions into waveforms</span>
    samples = compute_samples(channels, args.rate * args.time)

    <span class="co"># write the samples to a file</span>
    <span class="kw">if</span> args.filename == <span class="st">&#39;-&#39;</span>:
        filename = sys.stdout
    <span class="kw">else</span>:
        filename = args.filename
    write_wavefile(filename, samples, args.rate * args.time, args.channels, args.bits / <span class="dv">8</span>, args.rate)

<span class="kw">if</span> <span class="dt">__name__</span> == <span class="st">&quot;__main__&quot;</span>:
    main()</code></pre>
<p>You can execute the file directly and it will generate a pure sine tone.</p>
<h2 id="examples">Examples</h2>
<h3 id="sbagen">SBaGen</h3>
<p><a href="http://uazu.net/sbagen/">SBaGen</a> is a program which generates binaural beats. It’s reasonably complex, consisting of around 3000 lines of C. You can instruct SBaGen to generate a 200Hz pure sine tone in one channel and a 204Hz pure sine tone in the other channel by doing this:</p>
<pre class="console"><code>$ sbagen -i 202+2/10</code></pre>
<p>You can also generate multiple binaural beats simultaneously:</p>
<pre class="console"><code>$ sbagen -i 202+2/10 400+20/10</code></pre>
<p>The following emulates <code>sbagen -i</code>, but it’s about 100x slower. No problem for real-time use on a modern computer, but you’re better off using the real deal for serious use.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="ch">import</span> re
<span class="ch">import</span> sys
<span class="ch">from</span> wavebender <span class="ch">import</span> *
<span class="ch">from</span> itertools <span class="ch">import</span> *

<span class="kw">def</span> sbagen_phrase(phrase):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    147.0+4.0/1.27 -&gt; two sine_waves. one 145.0 hz; one 149.0 hz. each at amplitude of 0.0127.</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">if</span> <span class="st">&#39;pink&#39;</span> in phrase:
		<span class="co"># pink/40 -&gt; white_noise(amplitude=0.4)</span>
        amplitude = <span class="dt">float</span>(phrase.split(<span class="st">&#39;/&#39;</span>)[-<span class="dv">1</span>]) / <span class="fl">100.0</span>
        <span class="kw">return</span> (white_noise(amplitude),
                white_noise(amplitude))

    carrier, remainder = re.split(<span class="st">&#39;[+-]&#39;</span>, phrase, <span class="dv">1</span>)
    beatfreq, amplitude = remainder.split(<span class="st">&#39;/&#39;</span>)

    carrier = <span class="dt">float</span>(carrier)
    beatfreq = <span class="dt">float</span>(beatfreq)
    amplitude = <span class="dt">float</span>(amplitude) / <span class="fl">100.0</span>

    <span class="kw">return</span> (sine_wave((carrier - beatfreq/<span class="dv">2</span>), amplitude=amplitude),
            sine_wave((carrier + beatfreq/<span class="dv">2</span>), amplitude=amplitude))

<span class="kw">def</span> sbagen_line(line, length=<span class="ot">None</span>):
    <span class="co">&#39;&#39;&#39;</span>
<span class="co">    Given a sequence of (l, r), (l, r), return a sequence of (l, l), (r, r).</span>
<span class="co">    &#39;&#39;&#39;</span>
    <span class="kw">return</span> izip(*(imap(<span class="kw">lambda</span> s: islice(s, length), sbagen_phrase(phrase)) <span class="kw">for</span> phrase in line.split()))

<span class="kw">if</span> sys.argv[<span class="dv">1</span>:]:
    channels = sbagen_line(<span class="st">&#39; &#39;</span>.join(sys.argv[<span class="dv">1</span>:]))
<span class="kw">else</span>:
    sys.exit(<span class="dv">1</span>)

samples = compute_samples(channels)
write_wavefile(sys.stdout, samples)</code></pre>
<p>You can use it like this:</p>
<pre class="console"><code>$ ./sbagen.py 272.2+7.83/10 332+7.83/10 421.3+7.83/10 289.4+7.83/10 367.5+7.83/10 442+7.83/10 295.7+7.83/10 414.7+7.83/10 422+7.83/10 | aplay</code></pre>
<p>That generates a bunch of simultaneous binaural tones and uses <code>aplay</code> to play them in realtime.</p>
<h3 id="melody">Melody</h3>
<p>Here’s an example of a melody, using <code>itertools</code> and <code>wavebender</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="ch">from</span> wavebender <span class="ch">import</span> *
<span class="ch">from</span> itertools <span class="ch">import</span> *
<span class="ch">import</span> sys

<span class="kw">def</span> ncycles(iterable, n):
    <span class="co">&quot;Returns the sequence elements n times&quot;</span>
    <span class="kw">return</span> chain.from_iterable(repeat(<span class="dt">tuple</span>(iterable), n))

<span class="kw">def</span> waves():
    l = <span class="dt">int</span>(<span class="dv">44100</span>*<span class="fl">0.4</span>) <span class="co"># each note lasts 0.4 seconds</span>
    
    <span class="kw">return</span> cycle(chain(ncycles(chain(islice(damped_wave(frequency=<span class="fl">440.0</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">261.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">329.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l)), <span class="dv">3</span>),
                       islice(damped_wave(frequency=<span class="fl">440.0</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dv">3</span>*l), <span class="dv">3</span>*l),
                 
                       ncycles(chain(islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">261.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                                     islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l)), <span class="dv">2</span>),
                       chain(islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                             islice(damped_wave(frequency=<span class="fl">329.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l),
                             islice(damped_wave(frequency=<span class="fl">293.66</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dt">int</span>(l/<span class="dv">4</span>)), l)),
                       islice(damped_wave(frequency=<span class="fl">261.63</span>, amplitude=<span class="fl">0.1</span>, length=<span class="dv">3</span>*l), <span class="dv">3</span>*l)))

channels = ((waves(),), (waves(), white_noise(amplitude=<span class="fl">0.001</span>),))

samples = compute_samples(channels, <span class="ot">None</span>)
write_wavefile(sys.stdout, samples, <span class="ot">None</span>)</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Well, there’s your daily abuse of <code>itertools</code>. For more <code>itertools</code> madness, check out my <a href="/project-euler-solutions/">Project Euler Solutions</a>.</p>]]></summary>
</entry>
<entry>
    <title>Build a Media Server With Ampache and Transmission</title>
    <link href="http://noisehack.com/build-a-media-server-with-ampache-and-transmission/" />
    <id>http://noisehack.com/build-a-media-server-with-ampache-and-transmission/</id>
    <published>2011-04-12T00:00:00Z</published>
    <updated>2011-04-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This guide will teach you how to unleash your music collection. Access it from anywhere with an internet connection – on your laptop, your phone, at work, or on a plane.</p>
<p>This guide has three parts. Part one tells you how to build a server for less than $300. Part two discusses how to build a music collection. Part three discusses how to stream that collection across the internet. <!--more--></p>
<p>If you already have a computer that is connected to the Internet 24/7, you can skip part one.</p>
<h2 id="part-one-building-a-server">Part One: Building a Server</h2>
<p>We will need a computer to use as the server. You have three options here:</p>
<ol style="list-style-type: decimal">
<li>Re-use an old computer. The cheapest option.</li>
<li>Purchase a new computer. The easiest option.</li>
<li>Build a new computer. The educational option.</li>
<li>Purchase a <abbr title="Virtual private server">VPS</abbr>. Potentially the best option, with a few caveats (<a href="#vps-note">more details below</a>).</li>
</ol>
<p>If you chose option 3, read the following section. Otherwise you can skip past it.</p>
<h3 id="building-a-new-computer">Building a new computer</h3>
<p>The first thing to do when building a new computer is to come up with a parts list. It turns out that there are only six things you need to build a computer:</p>
<ul>
<li>CPU (aka processor)</li>
<li>Motherboard</li>
<li>RAM (aka memory)</li>
<li>Storage drive(s)</li>
<li>Power supply</li>
<li>Case</li>
</ul>
<p>Seasoned builders will be quick to point that there are a plethora of additional parts that can be used to build a computer. Expert builders will be even quicker to point out that you don’t even need a case or storage drives. For the purposes of this guide, however, I will focus on the six aforementioned parts. What follows is a list of the six parts I used to build my media server. They will most likely be out of date by the time you read this – just use them as an example.</p>
<h4 id="cpu-amd-athlon-ii-x2-250-60.99">CPU: AMD Athlon II X2 250 ($60.99)</h4>
<p>You don’t need a super-powerful processor in your server. That said, this processor packs an astonishing punch at 60 bucks.</p>
<h4 id="motherboard-gigabyte-ga-ma74gm-s2-740g-54.99">Motherboard: Gigabyte GA-MA74GM-S2 740G ($54.99)</h4>
<p>I’m really pleased with this motherboard. It’s very small (Micro ATX), yet it comes with a ton of features like onboard video, gigabit ethernet, sound, and the ability to upgrade to a discrete graphics card if desired.</p>
<p>If you use this motherboard (or similar), your media server will be able to perform double-duty as a media center if you hook it up to your TV. Expect to see another guide explaining how to do this in the future.</p>
<h4 id="ram-a-data-2gb-ddr2-800-32.99">RAM: A-DATA 2GB DDR2-800 ($32.99)</h4>
<p>Just some basic, cheap DDR2 RAM. Works well (did I mention it was cheap?).</p>
<h4 id="storage-drive-samsung-spinpoint-f4-2tb-5400-rpm-79.99">Storage drive: Samsung Spinpoint F4 2TB 5400 RPM ($79.99)</h4>
<p>You’re going to want a large drive in your media server to store your music collection. 2TB for 80 bucks is just an incredible deal. Less than three years ago I paid the same price for 10% of that.</p>
<h4 id="power-supply-logisys-575w-24.99">Power supply: Logisys 575W ($24.99)</h4>
<p>Normally I use high-end power supplies when building computers, so I was a bit wary of using this $25 power supply. It was substantially lighter than I am used to (heftier power supplies are typically higher-quality), but so far it has performed admirably.</p>
<h4 id="case-apex-tx-381-c-micro-atx-tower-29.99">Case: Apex TX-381-C Micro ATX Tower ($29.99)</h4>
<p>It’s a solid case. Very inexpensive. Somewhat loud.</p>
<p>That’s a grand total of around 280 bucks for a great server. Today you can probably get an even better machine for the same price or less.</p>
<p>Once you have all of the parts, you will need to put them together. Check out <a href="http://en.wikibooks.org/wiki/How_To_Assemble_A_Desktop_PC">How To Assemble A Desktop PC</a>, a great wikibook teaching you how to do that.</p>
<h3 id="setting-up-the-server">Setting up the server</h3>
<p>Now that you have a machine to use as your media server, you will need to install Linux on it. The version (or “distro”) I recommend is Ubuntu Server Edition. Take a look at the <a href="https://help.ubuntu.com/10.10/serverguide/C/index.html">Ubuntu Server Guide</a>. which will teach you everything you need to know.</p>
<p>You’re going to want to set up SSH access to your machine so that you can manage it remotely. You can find the details in the <a href="https://help.ubuntu.com/10.10/serverguide/C/openssh-server.html">OpenSSH section of the Ubuntu Server Guide</a>.</p>
<p>The final thing you need to do is to hook your new server up to the Internet. For streaming 320kbps music files, I recommend having a minimum upload bandwidth of around 384kbps (50KB/s). That’s what I used to have, and occasionally I had to reduce the streaming rate to 192kbps to eliminate stuttering. Miraculously my ISP increased my upload bandwidth to around 1mbps, for free (as far as I know). That’s more than enough for streaming music.</p>
<h3 id="vps-note">
A note on VPSs
</h3>
<p>If you opt to use a VPS, you don’t have to worry about setting up a Linux server with a 24/7 high speed internet connection. What you do need to worry about is violating your hosting provider’s Terms of Service. They may not appreciate you downloading and streaming music on their servers.</p>
<p>The other thing is that you likely won’t have unlimited disk space, even if you do have “Unlimited Disk Space!”. I would think twice before uploading a 400GB FLAC collection to a VPS.</p>
<p>If you can deal with these two conditions, then using your VPS as a media server is probably the best way to go. You get an extremely fast connection and you don’t have to worry as much about maintaining the server.</p>
<h2 id="part-two-building-a-music-collection">Part Two: Building a music collection</h2>
<p>What good is a music server without any music? That’s a problem that this section of the guide intends to solve. There are a lot of ways to get music these days: iTunes, purchasing directly from the artist, BitTorrent, and even purchasing from a store. For simplicity, I’m just going to focus on BitTorrent. If you don’t know what BitTorrent is, you may want to read <a href="http://www.bittorrent.org/introduction.html">this introduction</a> first.</p>
<p>This section of the guide will teach you how to access and use the best music repositories in the world (for free).</p>
<h3 id="installing-the-bittorrent-client">Installing the BitTorrent client</h3>
<p>You may be familiar with Transmission – it’s an excellent, easy-to-use BitTorrent client for Windows, Mac, and Linux. Transmission can also run in the background, as a daemon. This is called <code>transmission-daemon</code>. <code>transmission-daemon</code> comes with a beautiful web interface which you will be using to manage your torrents from anywhere in the world.</p>
<p>To install <code>transmission-daemon</code> on Ubuntu, ssh into your server and type the following:</p>
<pre class="console"><code>$ sudo aptitude install transmission-daemon</code></pre>
<p>First we make sure that <code>transmission-daemon</code> is not running:</p>
<pre class="console"><code>$ sudo /etc/init.d/transmission-daemon stop</code></pre>
<p>Now you want to configure <code>transmission-daemon</code>, so do:</p>
<pre class="console"><code>$ sudo $EDITOR /etc/transmission-daemon/settings.json</code></pre>
<p>You want to make the following changes:</p>
<pre class="js"><code>&quot;rpc-whitelist-enabled&quot;: false,
&quot;rpc-username&quot;: &quot;your-username&quot;,
&quot;rpc-password&quot;: &quot;your-password&quot;,</code></pre>
<p>This allows you to access <code>transmission-daemon</code> remotely, as long as you specify the correct username and password.</p>
<p>Finally, we restart <code>transmission-daemon</code>:</p>
<pre class="console"><code>$ sudo /etc/init.d/transmission-daemon start</code></pre>
<p>Now you can log in to the <code>transmission-daemon</code> web interface by pointing your web browser to http://your-server:9091/. Once you’ve logged in, you should see a nice interface where you can manage torrents and edit preferences. This is how you’ll be interacting with <code>transmission-daemon</code> most of the time.</p>
<p>What we need now is some torrents to download!</p>
<h3 id="finding-music-for-your-collection">Finding music for your collection</h3>
<p>I usually find new music based on recommendations from friends or Last.fm. Last.fm is a service which monitors your listening habits and then provides recommendations based on that data. It’s pretty cool, and it makes it easier to answer “So, what kind of music do you like?” with something other than “Oh, I listen to a little bit of everything.”.</p>
<p>Once you have some candidates for adding to your collection, you need to actually get your hands on the files. To do this, we use a BitTorrent search engine. The three that I use are (ranked from decent to best):</p>
<ul>
<li>The Pirate Bay</li>
<li>Demonoid</li>
<li>What.CD</li>
</ul>
<h4 id="the-pirate-bay">The Pirate Bay</h4>
<p>Most BitTorrent users will be familiar with The Pirate Bay. It’s one of the largest BitTorrent sites and certainly the most infamous. They offer a fair amount of music, probably enough for the casual user. There are no real quality standards here so you may have to search a bit before finding the good stuff. The Pirate Bay does not require registration.</p>
<h4 id="demonoid">Demonoid</h4>
<p>Demonoid is similar to The Pirate Bay in that it offers a wide range of content. I often find that if something isn’t on TPB, it’s on Demonoid (and vice versa). Demonoid requires registration, but it’s not difficult to get in.</p>
<h4 id="what.cd">What.CD</h4>
<p>What.CD is the holy grail for music enthusiasts. It is indisputably the greatest music collection ever assembled. If you’re lucky enough to get in, you will have access to pretty much every release of every album in any format you could want. They maintain their high quality by maintaining a high quality userbase, so if you want to get in you have two options: get an invite or pass an interview.</p>
<h3 id="a-brief-digression-on-formats">A brief digression on formats</h3>
<p>There are two kinds of music formats: lossy and lossless.</p>
<p>MP3, AAC, and OGG are all lossy formats, meaning that they discard some of the audio data in order to achieve smaller file sizes. Lossy formats are prevalent on public trackers like The Pirate Bay.</p>
<p>FLAC is a lossless format, meaning that it preserves all of the original audio data. As you build your music collection, you will learn more and more about FLAC. My collection consists solely of FLACs. One cool thing about FLAC that relates to this guide is that you can convert it to a lossy format on-the-fly for streaming over the internet – useful if you have a slow connection.</p>
<h2 id="part-three-serving-your-music-collection-over-the-internet">Part three: Serving your music collection over the Internet</h2>
<p>To stream your music over the Internet we will be using something called Ampache. The name is a portmanteau of the words Amp (as in amplifier) and Apache (the prominent web server).</p>
<p>Ampache provides a web interface to your music collection. You use the interface to create playlists. The playlists can then be played in the browser or opened in your favorite standalone media player. There are also Ampache clients for Android and iPhone, so you can access your full music collection on your phone. Additionally, Ampache can transcode your music on-the-fly to any format (useful for streaming to devices with slower internet connections).</p>
<h3 id="installing-ampache">Installing Ampache</h3>
<p>Ampache is included in the Ubuntu repositories. Just do:</p>
<pre class="console"><code>$ sudo aptitude install ampache mysql-server</code></pre>
<p>And the required programs will be installed for you. When asked which web server to configure automatically, select apache2. When asked to restart the web server, select “Yes”. Choose the root password for your MySQL server and remember it.</p>
<p>At this point, try navigating to http://your-server/ampache/. If the page is not found, do the following:</p>
<pre class="console"><code>$ sudo $EDITOR /etc/apache2/apache2.conf</code></pre>
<p>Add the following to the bottom of that file:</p>
<pre class="sourceCode apache"><code class="sourceCode apache">Include<span class="st"> /etc/ampache/ampache.conf</span></code></pre>
<p>Restart the web server:</p>
<pre class="console"><code>$ sudo /etc/init.d/apache2 restart</code></pre>
<p>Now, open http://your-server/ampache/ in a web browser. You will see a webpage entitled ‘Ampache Installation’. Click on ‘Start configuration’ near the bottom of the page.</p>
<p>On the next page, enter the MySQL root password in the ‘MySQL Administrative Password’ box. Then click ‘Insert Database’.</p>
<p>On this page, type ‘root’ into the ‘MySQL Username’ box. The ‘MySQL username’ is the MySQL root password you entered on the previous page. Click ‘Write Config’ and you will be prompted to download an <code>ampache.cfg.php</code> file. Save this file to your local machine.</p>
<h3 id="configuring-ampache">Configuring Ampache</h3>
<p>Make the following changes to <code>ampache.cfg.php</code>:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">xml_rpc:</span> &quot;true&quot;
<span class="fu">allow_zip_download:</span> &quot;true&quot;
<span class="fu">transcode_m4a:</span> &quot;false&quot;</code></pre>
<p>If you would like to transcode your FLACs on-the-fly, make the following change:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">transcode_flac:</span> &quot;true&quot;</code></pre>
<p>If you have multiple formats of each album (e.g. if you download albums in MP3, OGG, AAC, and FLAC), each format will be indexed. To eliminate these duplicates, you can opt to only index one of these formats. To only index FLAC:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">catalog_file_pattern:</span> &quot;flac&quot;</code></pre>
<p>When you’ve finished editing <code>ampache.cfg.php</code>, copy it to the <code>/etc/ampache</code> directory on your server:</p>
<pre class="console"><code>$ scp /path/to/ampache.cfg.php root@your-server:/etc/ampache/</code></pre>
<p>Once <code>ampache.cfg.php</code> is in place on your server, click ‘Check for Config’. Both ‘Ampache.cfg.php Exists’ and ‘Ampache.cfg.php Configured?’ should now say ‘OK’. Click ‘Continue to Step 3’.</p>
<p>Finally, setup the administrator account. Once you’ve filled out the form, click ‘Create Account’.</p>
<p>Login to your Ampache installation as the administrator. We will now configure Ampache to scan your music collection.</p>
<p>On the menu at the left of the page, click the ‘Admin’ icon (looks like a small server). Then click ‘Add a Catalog’.</p>
<p>The catalog name can be anything you like. ‘Path’ should be set to to the path of your music location. If you are using <code>transmission-daemon</code> and would like all of its downloads to be indexed, use <code>/var/lib/transmission-daemon/downloads/</code>. Then click ‘Add Catalog’.</p>
<p>Once your music collection has been indexed, click ‘Continue’. Now click on the ‘Preferences’ icon in the menu on the left of the page.</p>
<p>If you have opted to transcode FLACs on-the-fly, click on ‘Streaming’ and set your ‘Transcode Bitrate’ to something more reasonable, like 320. Click ‘Update Preferences’ and you’re done.</p>
<h3 id="using-ampache">Using Ampache</h3>
<p>Now you’re ready to use Ampache. Using Ampache is basically a two-step process. First you queue some music into a playlist. Then you open that playlist in a media player which handles the streaming for you.</p>
<h4 id="queueing-music">Queueing Music</h4>
<p>Click on the “Home” icon in the menu on the left. Click on “Albums” to view a list of your albums. If you click the green plus icon next to any album title, it will be loaded into your playlist. You’ll see the tracks in the playlist view on the right side of the screen.</p>
<h4 id="opening-the-playlist">Opening the playlist</h4>
<p>Now that you have some music in the playlist, click the “Play” icon (looks like a broadcast tower) located above the playlist on the right side of the screen. You will be prompted to download a playlist file. Download it and open it with the media player of your choice – Totem or VLC for example. You should hear some music. Enjoy!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully you now have enough information to build a killer media server. I covered a lot of ground in this guide, so feel free to ask any questions you may have.</p>]]></summary>
</entry>

</feed>
